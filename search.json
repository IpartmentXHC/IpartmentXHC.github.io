[{"title":"hello","url":"/2022/07/11/hello/","content":"简介这是我的正式的第一篇blog hexo艹\n","categories":["闲话","blog建设"],"tags":["hexo keep"]},{"title":"金三胖","url":"/2022/07/11/%E9%87%91%E4%B8%89%E8%83%96/","content":"解压打开是GIF 动图\n用stegsolve打开\n\n逐帧逐帧看\n\n\n\n可得flag\n","categories":["刷题记录","BUUCTF","misc"]},{"title":"二维码","url":"/2022/07/11/%E4%BA%8C%E7%BB%B4%E7%A0%81/","content":"#解压打开发现是张二维码图片 用QR Research 探查一下\n\n没有什么东西\n打开kali 用binwalk 探查一下 藏了一个压缩包 \n用010 打开观察加密信息 不是伪加密 \n试了试二维码的内容secret is here\n也不对 那只能爆破了\n\n\n解压得flag\n","categories":["刷题记录","BUUCTF","misc"]},{"title":"你竟然赶我走","url":"/2022/07/11/%E4%BD%A0%E7%AB%9F%E7%84%B6%E8%B5%B6%E6%88%91%E8%B5%B0/","content":"#只有一张JGP图片 猜是图片隐写\n用010打开\n\n图片结尾藏了flag\n\n因为JPG这种图片文件读到 FF D9（文件尾）就不会在读了 因此可以在文件尾添加东西不影响图片的显示\n\n","categories":["刷题记录","BUUCTF","misc"]},{"title":"typora-picgo-github三者联动实现自动上传图片","url":"/2022/07/12/typora-picgo-github%E4%B8%89%E8%80%85%E8%81%94%E5%8A%A8%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0/","content":"利用github存储代码和图片 typora编写blog picgo上传图片终于经过俩天的踩坑 终于建立一套方便的博客上传系统\n一、GitHub图床仓库的建立和配置1、创建GitHub图床仓库\n创建GitHub账号 不会的话 上网搜 教程很多\n\n新建GitHub仓库\n\n\n2、获取GitHub的token\n点击头像进入settings\n\n\n进入开发者选项\n\n\n生成新的token\n\n\n\n注意保存token 它只会出现一次 错过了只能重新生成\n\n\n\n\n\n\n\n\n\n\n二、PicGo的安装和配置1、PicGo的下载进入PicGo的官网下载\n\nhttps://github.com/Molunerfinn/PicGo/releases\n\n\n2、PicGo的配置\n进入图床设置 选择GitHub 如图填入信息\n\n设定仓库名 填写 用户名&#x2F;仓库名\n\n分支 默认master\n\n设定token 填入刚刚保存的token\n\n后面两项可以暂时不填\n\n点击确定\n\n\n进入picgo设置 建议打开时间戳重命名\n\n\n\n三、typora的设置1、下载typora\nTypora 官方中文站 (typoraio.cn)\n\n2、typora的相关设置\n点击文件进入偏好设置\n\n\n\n\n关联成功后即可开始使用\n\n","categories":["闲话","blog建设"]},{"title":"N种方法解决","url":"/2022/07/12/N%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3/","content":"解压发现是exe文件 运行不了\n用exeinfo PE侦测一下\n\nbase64&#x2F;32 加密文件 用010打开\n\n将base64加密的密文复制\n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\n\n去在线网站解码\n\n是png图片 下载下来\n是张二维码图片\n\n用QR打开\n\n得flag\n\nflag{dca57f966e4e4e31fd5b15417da63269}\n\n","categories":["刷题记录","BUUCTF","misc"]},{"title":"乌镇峰会种图","url":"/2022/07/12/%E4%B9%8C%E9%95%87%E5%B3%B0%E4%BC%9A%E7%A7%8D%E5%9B%BE/","content":"是一张图片 \n用stegsolve 打开 并没有发现什么\n用binwalk 探查 没有发现什么\n用010打开\n发现flag就藏在最后\n\n\nflag{97314e7864a8f62627b26f3f998c37f1}\n\n","categories":["刷题记录","BUUCTF","misc"]},{"title":"基础破解","url":"/2022/07/12/%E5%9F%BA%E7%A1%80%E7%A0%B4%E8%A7%A3/","content":"题目有提示 四位数字加密\n\n用ARCHPR暴力破解一下\n\n解压得flag.txt\n\nbase64加密\n\n得flag\n\nflag{70354300a5100ba78068805661b93a5c}\n\n最后分享一张图片\n\n","categories":["刷题记录","BUUCTF","misc"]},{"title":"LSB","url":"/2022/07/12/LSB/","content":"题目提示的很明显 LSB隐写\n\nLSB图片隐写\n用Stegsolve打开\n发现在 红 绿 蓝 的0通道有隐写\n\n\n\n提取一下\n\n\n文件头为PNG 说明是PNG图片\n\n\n保存一下 以  .png  结尾\n是张二维码图片\n用QR 打开\n\n得flag\n\nflag{1sb_i4_s0_Ea4y}\n\n","categories":["刷题记录","BUUCTF","misc"]},{"title":"wireshark","url":"/2022/07/12/wireshark/","content":"写这题需要wireshark工具\n\nWireshark · Go Deep.\n\n用wireshark打开 抓取POST的包\n\n\n找到包后 右键追踪http流\n\n因为题目要求我们找密码 \n\n\n直接搜索 password 或者 眼力好一眼看见\n\nflag{ffb7567a1d4f4abdffdb54e022f8facd}\n\n","categories":["刷题记录","BUUCTF","misc"]},{"title":"zip伪加密","url":"/2022/07/12/zip%E4%BC%AA%E5%8A%A0%E5%AF%86/","content":"zip伪加密的原理参考这篇博客\n\nctf伪加密\n\n用010打开\n\n按blog所说应是真加密\n\n但题目直言是伪加密 只好硬着头皮改\n\n改完后 解压就不需要密码了\n\n\nflag{Adm1N-B2G-kU-SZIP}\n\n\n一般情况下伪加密只有局部加密为00 09 全局为00 00\n\n\n","categories":["刷题记录","BUUCTF","misc"]},{"title":"文件中的秘密","url":"/2022/07/12/%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%A7%98%E5%AF%86/","content":"一张 路飞 的图片\n\n各种方法都试了一下 没有发现什么\n最后在图片属性 详细信息中找到flag\n\n\nflag{870c5a72806115cb5439345d8b014396}\n\n","categories":["刷题记录","BUUCTF","misc"]},{"title":"被嗅探的流量","url":"/2022/07/12/%E8%A2%AB%E5%97%85%E6%8E%A2%E7%9A%84%E6%B5%81%E9%87%8F/","content":"用wireshark 打开\nTCP简介\n\n追踪TCP流\n直接查找flag\n\n\nflag{da73d88936010da1eeeb36e945ec4b97}\n\n","categories":["刷题记录","BUUCTF","misc"]},{"title":"镜子里面的世界","url":"/2022/07/12/%E9%95%9C%E5%AD%90%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%96%E7%95%8C/","content":"LSB隐写 用stegsolve 打开\n在红 绿 蓝 0通道 有隐写\n\n\n\n提取一下发现flag\n\n\nflag{st3g0_saurus_wr3cks}\n\n","categories":["刷题记录","BUUCTF","misc"]},{"title":"网鼎杯-2020-青龙组-jocker","url":"/2022/07/13/%E9%9D%92%E9%BE%99%E7%BB%84-jocker/","content":"观察程序用PE 探查一下\n\n是32位程序 无壳 用IDA 打开\n这里如果你IDA版本较高 可以直接F5生成伪代码\n此时版本为 IDA Pro 7.7\n\n但是有些较低的不行 所以我讲一下 无法直接F5的情况\n 这里无法生成伪代码是因为 栈不平衡\n勾选上 栈指针  Options-&gt;Generral-&gt;Stack pointer\n\n就可以看到栈指针的情况了\n\n有两处栈不平衡情况\n\ntips：在call函数最后 retn指令会使得栈指针恢复被调用前的数值 \n\n使用快捷键 Alt + k 修改新旧sp指针的差值为0\n修改第一处：\n \n\n修改第二处：\n\n\nF5查看伪代码\n看到一个VirtualProtect函数 没有遇到过 查一下\n\n\n VirtualProtect函数__virtualprotectex\n\n是一个加密函数 加密encrypt函数 暂时还用不到 跳过\n\n有两个函数 wrong 和 omg 使用了 str\nwrong:\nchar *__cdecl wrong(char *a1)&#123;  char *result; // eax  int i; // [esp+Ch] [ebp-4h]  for ( i = 0; i &lt;= 23; ++i )  &#123;    result = &amp;a1[i];    if ( (i &amp; 1) != 0 )      a1[i] -= i;    else      a1[i] ^= i;  &#125;  return result;\n\nomg:\nint __cdecl omg(char *a1)&#123;  int v2[24]; // [esp+18h] [ebp-80h] BYREF  int i; // [esp+78h] [ebp-20h]  int v4; // [esp+7Ch] [ebp-1Ch]  v4 = 1;  qmemcpy(v2, &amp;byte_4030C0, sizeof(v2));  for ( i = 0; i &lt;= 23; ++i )  &#123;    if ( a1[i] != v2[i] )      v4 = 0;  &#125;  if ( v4 == 1 )    return puts(&quot;hahahaha_do_you_find_me?&quot;);  else    return puts(&quot;wrong ~~ But seems a little program&quot;);&#125;\n\n写一下脚本\n\n错的flag 题目没有那么简单\n再往后看\n\n有个for循环 循环了187次 有点像在还原程序\n\nencrypt函数打不开 报错 查看汇编代码 大多还是数据 基本上确定了for循环在进行解密\n动态调试 去壳这里用x32debug 动态调试\n\n一步一步调试 找到主函数下的for循环\n按下F4 运行到for循环的下一步 \n按下F7进入encrypt函数内部\n\n\n有正确的汇编代码\n将解密完的程序dump 出来\n\n\n将dump出的新程序拖进IDA \n\n入口变成了 start 这是dump程序默认更改的 点击start函数名 按X查看调用 易找到原来的main函数\n\n还原的encrypt函数\nint __cdecl start(int a1)&#123;  int v2[19]; // [esp+1Ch] [ebp-6Ch] BYREF  int v3; // [esp+68h] [ebp-20h]  int i; // [esp+6Ch] [ebp-1Ch]  v3 = 1;  qmemcpy(v2, &amp;unk_403040, sizeof(v2));  for ( i = 0; i &lt;= 18; ++i )  &#123;    if ( (char)(*(_BYTE *)(i + a1) ^ aHahahahaDoYouF[i]) != v2[i] )    &#123;      puts(&quot;wrong ~&quot;);      v3 = 0;      exit(0);    &#125;  &#125;  puts(&quot;come here&quot;);  return v3;&#125;\n\n还原的finally函数\nint __cdecl sub_40159A(int a1)&#123;  unsigned int v1; // eax  char v3[9]; // [esp+13h] [ebp-15h] BYREF  int v4; // [esp+1Ch] [ebp-Ch]  strcpy(v3, &quot;%tp&amp;:&quot;);  v1 = time(0);  srand(v1);  v4 = rand() % 100;  v3[6] = 0;  *(_WORD *)&amp;v3[7] = 0;  if ( (v3[(unsigned __int8)v3[5]] != *(_BYTE *)((unsigned __int8)v3[5] + a1)) == v4 )    return puts(&quot;Really??? Did you find it?OMG!!!&quot;);  else    return puts(&quot;I hide the last part, you will not succeed!!!&quot;);&#125;\n\nencrypt函数加密思路将a1的前19为与“hahahaha_do_you_find_me?”异或 其中a1就是我们的输入字符串\n\nfinally函数的加密思路\n函数逻辑 看了很久不是很懂 再加上 还有随机数的干扰 这里就无法猜出它的解密方法 \n只能退一步 猜还是利用了encrypt函数的异或\n因为 flag{…..} 最后一个必定是** }**  可以知道是 71 与 ”:” 异或 \n进一步猜 前四字符都是 和 71异或\n解密脚本store = [0x0E,    0x0D,    0x09,         0x06,    0x13,         0x05,    0x58,    0x56, 0x3E,    0x06,  0x0C,  0x3C,    0x1F,   0x57,    0x14,  0x6B,    0x57,    0x59, 0x0D]key = [0x68, 0x61, 0x68, 0x61, 0x68, 0x61, 0x68, 0x61, 0x5F, 0x64,       0x6F, 0x5F, 0x79, 0x6F, 0x75, 0x5F, 0x66, 0x69, 0x6E, 0x64,       0x5F, 0x6D, 0x65, 0x3F]input1 = []for i in range(len(store)):    input1.append(store[i] ^ key[i])    print(chr(input1[i]), end=&quot;&quot;)key2 = [37, 116, 112, 38, 58]for i in range(len(key2)):    print(chr(key2[i] ^ 71), end=&quot;&quot;)#flag&#123;d07abccf8a410cb37a&#125;\n\n\n参考WP:[(60条消息) 网鼎杯 2020 青龙组]jocker（详解）_ST4RBOY的博客-CSDN博客_网鼎杯jocker\n\n","categories":["刷题记录","BUUCTF","re"]},{"title":"GWCTF-2019-re3","url":"/2022/07/18/GWCTF-2019-re3/","content":"看题目PE查壳\n无壳64位的linux程序 \n用IDA打开找到main函数\n\n接受一个 32位的 字符串\n存在一个mprotect 函数 紧接着一个大循环 猜测是加密后解密\n\n查看汇编窗口 果然如此\n\n因为是Linux程序 本人暂时不知道如何利用动态调试去“去除“这个函数的”壳“\n去壳只能利用IDC脚本静态”去壳“ \n\nshift + F2 就可以调出脚本编辑器 输入脚本后点击Run 即可 \n#include &lt;idc.idc&gt;static main()&#123;    auto addr = 0x402219;    auto i = 0;    for(i=0;i&lt;224;i++)    &#123;        PatchByte(addr+i,Byte(addr+i)^0x99);    &#125;&#125;\n\n\n\n\n仔细观看这些函数 都是一些比较复杂的 用findcrypt 插件(需要自行下载)\n\nsub_40207B函数\n其中sub_401CF9是MD5加密函数 \na1是函数导入的参数 我们盯着 a1看\na1只和V2产生联系\n\n\n按理说：只要将base64的码表 MD5加密俩次就可以获得 a1的值了 但是事实并非如此 其中的原因 本人暂时还不知 只能利用动调得到unk_603170\n\n\nCB8D493521B47A4CC1AE7E62229266CE\n\n\n\nsub_40221A函数由findcrypt插件可知此函数中存在AES加密\n\nbyte_6030A0中存放的就是A1最后AES加密出的密文 \nBC0AADC0147C5ECCE0B140BC9C51D52B46B2B9434DE5324BAD7FB4B39CDB4B5B\n\n其中unk_603170就是我们AES中的密钥\n写脚本from Crypto.Cipher import AESfrom Crypto.Util.number import *password = long_to_bytes(0xCB8D493521B47A4CC1AE7E62229266CE)aes = AES.new(password,mode=AES.MODE_ECB) en_text = long_to_bytes(0xBC0AADC0147C5ECCE0B140BC9C51D52B46B2B9434DE5324BAD7FB4B39CDB4B5B)den_text = aes.decrypt(en_text) print((den_text))\n\n\nflag{924a9ab2163d390410d0a1f670}\n\n","categories":["刷题记录","BUUCTF","re"]},{"title":"java学习总结","url":"/2022/07/19/java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"Java开发入门Java概述略\nJava开发环境搭建略\nJava运行机制Java程序运行时，要经过编译和运行两个步骤\n\n首先采用通用的java编译器将java源程序编译成为与平台无关的字节码文件（class文件）\n然后由java虚拟机（JVM）对字节码文件解释执行。\n\n\n编译后的.class文件可以通过不同版本的JVM，直接在相应的操作系统中运行。\n\nJava编程基础Java程序的组成要素标识符略\n关键字略\n注释略\n数据类型略\n常量略\n变量略\n数据的标准输入、输出通过键盘输入数据通过Scanner类来实现键盘的数据输入\n\n引用Scanner所在的包：import java.util.Scanner;\n\n定义Scanner对象：Scanner input &#x3D;new Scanner(System.in);其中对象名（input）由程序员自定义，systeam.in 表示输入设备——键盘\n\n通过输入对象调用相应的方法接受相应类型的数据。\n\n\n\n格式\n接受数据类型\n\n\n\ninput.nextByte()\n接受一个byte型数据\n\n\ninput.nextInt()\n接受一个int型数据\n\n\ninput.nextShort()\n接受一个short型数据\n\n\ninput.nextLong()\n接受一个long型数据\n\n\ninput.nextFloat()\n接受一个float型数据\n\n\ninput.nextDouble()\n接受一个double型数据\n\n\ninput.nextLine()\n接受一个string型数据\n\n\n\n\n代码演示:\nScanner input =new Scanner(Systen.in);int a =input.newInt();\n\n显示屏输出数据常见方法：\n\n\n\n方法\n特点\n\n\n\nSysteam.ou.print(字符串)\n显示字符串内容 不换行\n\n\nSysteam.out.println(字符串)\n显示字符串内容，有换行\n\n\nSysteam.ou.printf(“字符串”,变量列表)\n与C语言相同，按格式显示字符串内容\n\n\n\n字符串可以是单个字符串，可以是其他变量，也可以是字符串和其他变量通过加号“+”拼接成的字符串。\n\n运算符和表达式略\n选择结构语句if语句略\nswitch语句略\n循环结构语句while循环略\ndo…while循环略\nfor循环略\n循环嵌套略\n跳转语句略\n方法方法的定义Java中的方法类似于C语言中的函数 但方法又有不同的含义。\nJava中的方法是类的动态属性，表示类具有的功能和行为，用来进行对象之间的信息传递。并且所有的方法必须再类中定义。\n方法定义格式：\n[修饰符]返回值类型 方法名(形参 1 ，形参 2，....)&#123;\t//方法体\treturn 返回值&#125;\n\n修饰符有俩种：\n\n访问权限：public \tprotected \tprivate\t (默认)\n\n描述方法：\nstatic:静态修饰符abstract:抽象修饰符final:最终修饰符\n\n\n方法的调用方法调用时，注意：\n\n形参和实参特征匹配：参数个数 参数的数据类型\n参数的传递包括传值的传址传值时：形参的变化不改变实参传址时：形参的值会改变实参的值\n如果方法有返回值利用return，获取方法的返回值\n\n方法的重载方法重载的定义：\n​\t在同一个作用于内，方法名相同，参数特征不同(参数的个数或参数的类型不同)的一系列方法\n方法重载的调用机制\n\n匹配方法名\n匹配参数特征\n\n数组一维数组数组的声明\n数组类型 数组名称 [ ]\n数组类型 [ ] 数组名称\n\n数组类型可以是 基本数据类型或引用数据类型\n[ ] 是数组的标志 可以放在数组名称后面 以可以放在前面\n创建数组声明数组只是定义一个数组，并没有开辟储存空间，需通过创建数组才能为数组开辟指定长度的储存空间。\n\n数组名称 &#x3D; new 数组类型 [数组长度]\n\n数组访问略\n数组初始化略\n二维数组略\n类与对象类类的定义类是对象的抽象，它用于描述一组对象的共同特征和行为。\n类中可以定义成员变量和成员方法。\n\n成员变量用于描述对象的特征，也被称作属性\n成员方法用于描述对象的行为，可简称为方法\n\n类的定义格式为\n[类修饰符] class ClassName&#123;//成员变量定义//成员方法定义&#125;\n\n类修饰符有：public abstract final (默认空)\n\n注意：\n\n当类修饰符为public时，表示该类为公共类，类名必须于文件名相同，且一个Java文件中只能包含一个公共类，但可包含多个非公共类。\n类名的各个单词首字母都要大写；成员变量名，成员方法名称第一个字母小写，其他单词首字母都大写。\n\n\n成员变量定义格式：\n\n[修饰符] 数据类型 成员变量名称\n\n赋初始值：\n\n声明时直接给定初始值\n如果没有明确指定变量初始值，由系统给定默认的初始变量\n通过构造方法给成员变量赋值\n\n\n系统不会为局部变量设置初始值\n\n成员方法定义格式：\n[修饰符] 返回数据类型 方法名(形参列表)&#123;//方法体&#125;\n\n\n与普通方法基本相同\n\n对象的声明、实例化程序要完成具体的功能，需要通过实例化对象调用类成员来实现。\n在使用对象前，需声明对象，然后为该对象创建创建储存空间，为成员变量给定初始值。\n具体格式为：\n\n类名 对象名称；对象名称 &#x3D; new 类名(实参列表)；\n\n简化版：\n\n类名 对象名称  &#x3D; new 类名(实参列表)；\n\n类成员的访问在类内自身的成员变量和成员方法可以直接访问，而在类外一般通过类对象来访问。\n具体格式为：\n\n对象名.成员变量;\n对象名.成员方法;\n\n类的封装性\n\npublic\t     允许在类外且项目内任何地方访问\n默认            允许在类外且包内的任何地方访问\nprotected  允许在类外且子类内的任何地方访问\nprivate       只允许在类内访问\n\n构造方法构造方法的定义构造方法是类的一种特殊方法，主要作用是在创建对象的同时，初始化类的实例对象。\n构造方法必须满足如下两个条件：\n\n构造方法的方法名必须与类名相同\n构造方法没有返回值，因此方法同定义不需要返回类型修饰符，void也不需要，且方法体中不能用return。\n\n\n构造方法具有方法的共性，但也有特殊之处：\n\n构造方法的方法名必须与类名相同\n构造方法没有返回值，因此方法头定义不需要返回类型修饰符\n构造方法的一般作用是对对象成员的初始化\n构造方法在用户创建对象时，由系统自动调用进行初始化\n构造方法的修饰符只能为访问修饰符\n\n\n类中系统默认给定无参构造方法\n\n构造方法的重载略\nThis关键字具体用法：\n\n在类方法中调用对象成员时，系统默认在对象成员前加上this，表示访问的是当前对象成员 即成员变量或对象方法\n通过this关键字可以明确访问类成员，解决于局部变量名称冲突问题\n当需要在构造方法中调用另一个构造方法时，可以通过执行“this([实参1 实参2 …])”来实现\n\n对象数组对象数组的声明和创建\n声明和创建数组类名 [] 数组名 &#x3D;new 类名[n];\n创建对象储存空间数组名[i] &#x3D;new 类名([实参列表])\n\n数组对象的访问格式为：\n数组名[i].成员；\n子对象子对象定义：\n所谓子对象，就是一个类对象作为另一个类的成员\n类与类之间利用关系类与类之间的关系有：\n\n包含关系\n利用关系\n继承关系\n\nstatic关键字静态成员变量使用static关键字修饰得成员变量，称之为静态成员变量\n格式为：\n\n[修饰符] static 数据类型 变量名；\n\n静态成员变量和一般成员变量区别：\n\n归属及内存分配空间不同一般成员变量是属于对象得，即只有创建了对象后，一般成员变量才存在，且其内存分配空间于各自得对象相关。静态成员变量是属于类的，即在装载类定义代码时，系统为静态成员变量分配得独立得储存空间，所有属于这个类得对象都共享这个储存空间\n\n调用方法不同静态成员变量时属于类得，但也可以看作对象得成员变量，所以静态成员变量除了可以作为一般成员变量通过对象调用外，还可以通过类名来调用类名.成员变量名对象名.成员变量名\n\n\n静态成员方法使用static修饰的成员方法，就是静态成员方法。\n静态成员方法也属于类，在装载了类定义代码后，就可以通过类来调用静态成员方法。同样，也可以利用对象来调用静态成员方法\n调用格式：类名.成员方法([实参列表])\n对象名.成员方法([实参列表])\n静态代码块载Java类中，使用一大对大括号括起来的若干行代码称之为一个代码块，用static关键字修饰的代码块被称之为静态代码块。\n当类被加载时，静态代码块会被执行。由于类只加载一次，因此静态代码块只被执行一次。\n静态代码块常用于进行初始化。\n继承和多态类的继承继承的概念在Java中类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类称之为子类（派生类），现有类称之为父类（超类、基类）。\n类的继承具有传递性，即子类还可以派生子类，最终形成一个类层次结构。\n按照继承的方式的不同，继承可以分为直接继承和间接继承。\n直接继承是由父类直接派生出子类，间接继承是由父类派生出的子类的子类。\n继承的定义想声明一个类继承另一个类，需要使用extends关键字\n具体格式为：\n[修饰符]class 子类名 extends 父类名&#123;//类体&#125;\n\n\njava中 一个子类只能继承一个父类，即单继承。\n子类自动继承父类中除了构造方法外的所有属性和方法。\n\n方法的重载和覆盖（重写）在继承关系中，当子类中的声明的成员方法与父类中某个成员方法名字相同但参数特征不同时，也称方法重载。\n当子类中声明的成员方法与父类中某个成员方法原型相同时，子类方法会覆盖父类方法，也称子类重写了父类方法。\nsuper关键字当子类重写了父类方法后，子类方法会覆盖子类父类的相应方法，使得无法访问父类被重写的方法。\nsuper关键字就可以解决这个问题。\n可以通过super关键字来访问父类的成员变量，成员方法，构造方法。\nsuper关键字的具体格式为：\nsuper.成员变量\nsuper.成员方法([实参 1 ，实参 2 …])\n构造方法在继承关系中，当创建子类对象时，不但会调用子类构造方法，还会调用父类构造方法。\n调用机制：\n\n创建子类对象时，系统自动调用父类后，在调用子类构造方法。\n调用顺序是，首先在子类中找到匹配的构造方法，并进入方法体，调用父类构造方法，然后返回执行子类构造方法后续语句。\n调用父类构造方法时，如果子类构造方法中没有显式调用或显式调用语句，则默认调用父类的无参构造方法。\n显式调用语句“super( )”或”super(实参1，实参2…)”必须放在子类构造方法体的最前面。\n\n多态多态的定义多态性是指对于同一消息，不同类的对象做出的不同反应的现象。\n是指不同类的对象调用同一个方法名的成员方法时，执行不同代码段的现象。\n要实现多态性，需具备：\n\n声明父类的引用，让父类引用指向子类存储空间，通过父类的引用的调用方法。\n要调用的方法必须包含在父类和子类中。\n\n抽象类抽象的定义随着抽象层次的不断加深，可能会出现抽象概念类，由于这些类是抽象的，所以有的方法不能具体实现。\n抽象方法和抽象类的定义格式：\nabstract class 抽象类名&#123;//成员变量的声明[修饰符] abstract 返回值类型 方法名([参数列表]);\t//抽象方法定义&#125;\n\n\n抽象类本身不能被实例化的类，只能作为其他类的父类。\n子类必须实现父类的抽象方法，否则子类不能实例化对象。\n\n接口接口的定义接口用关键字interface修饰，包括成员变量和成员方法。\n成员变量为常量 默认使用 public static final 修饰 允许进行一次且仅一次的赋值。\n成员方法全部为抽象方法，默认使用关键字 public abstract 修饰\n具体定义为：\n[public] interface 接口名&#123;    //成员变量的声明，修饰符(public static final) 可省    变量类型 变量名称 = 常量值;    //抽象方法的声明，修饰符(public abstract)可省    返回值类型 方法名(形参1 ，形参2 ....);&#125;\n\n接口的实现接口中的成员方法只能定义为抽象类，它本身不能提供方法的实现。\n接口中的抽象方法是通过引用接口的类实现的，如果某个类要引用某个接口，需要在类定义时使用implement来声明引用接口\n接口格式为：\nclass 类名 implement 接口1，接口2，接口3....&#123; \t//成员变量的定义    //成员方法的定义 \t//接口中所有的抽象方法的重写 &#125;\n\n\n一个类只能直接继承一个父类，但可以同时引用多个接口。\n\n包包的定义Java中的类文件都是通过包来进行管理的。\n\n包的声明语句必须放在Java源文件的最前面。\n包的名字一般为小写，用圆点操作符( . )指明包的层次。\n\n包间访问\n前缀包名发再要引用的类名前面添加这个类名所属的包名，包和引用的类之间使用圆点操作符连接max.IntgerMax.getMax(1,2)  访问max 中的IntegerMax类成员\n使用引用包语句(import)使用引用包语句也可以直接将其他包中的类加载到程序中，这样使用时不需要加上包名引用了实现语法：**import 包名.类名 **\t\t\t\t引用具体某个包*import 包名. **\t\t\t\t\t  将整个包装载\n\n\n\n","categories":["知识总结","Java"]},{"title":"我的第一行Android代码.Android学习.01","url":"/2022/07/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E8%A1%8CAndroid%E4%BB%A3%E7%A0%81-Android%E5%AD%A6%E4%B9%A0-01/","content":"Android系统架构Android 大致可以分为四层架构：Linux 内核层、系统运行库层、应用框架层和应用层。\n\nLinux 内核层   Android 系统是基于 Linux 内核的，这一层为 Android 设备的各种硬件提供了底层的驱动，如 显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi 驱动、电源管理等\n系统运行库层这一层通过一些 C&#x2F;C++库来为 Android 系统提供了主要的特性支持。同样在这一层还有 Android 运行时库，它主要提供了一些核心库，能够允许开发者使用 Java 语言来编写 Android 应用。另外，Android 运行时库中还包含了 Dalvik 虚拟机（5.0 系统之后改为 ART 运行环境），它使得每一个 Android 应用都能运行在独立的进程当中，并且拥有一个自己的 Dalvik 虚拟机实例。相较于 Java 虚拟机，Dalvik 是专门为移动设备定制的，它针对手机内存、 CPU 性能有限等情况做了优化处理。\n应用框架层这一层主要提供了构建应用程序时可能用到的各种 API，Android 自带的一些核心应用就是 使用这些 API 完成的，开发者也可以通过使用这些 API 来构建自己的应用程序。\n应用层所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序，或 者是你从 Google Play 上下载的小游戏，当然还包括你自己开发的程序。\n\n准备工具\nJDK。JDK 是 Java 语言的软件开发工具包，它包含了 Java 的运行环境、工具集合、基础 类库等内容。\nAndroid SDK。Android SDK 是谷歌提供的 Android 开发工具包，在开发 Android 程序时， 我们需要通过引入该工具包，来使用 Android 相关的 API。\nAndroid Studio。Android Studio 在开发 Android 程序方面要远比 Eclipse 强 大和方便得多。\n\n分析Android程序项目结构这里我们将项目结构模式切换成 Project。\n观察整个结构目录的内容：\n\n.gradle和.idea这两个目录下放置的都是 Android Studio 自动生成的一些文件，我们无须关心，也不要去手动编辑。\napp项目中的代码、资源等内容几乎都是放置在这个目录下的，我们后面的开发工作也基本都是 在这个目录下进行的，待会儿还会对这个目录单独展开进行讲解。\ngradle   这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle 下载好，而是会自动根据本地的缓存情况决定是否需要联网下载 gradle。\n.gitignore   这个文件是用来将指定的目录或文件排除在版本控制之外的。\nbuild.gradle这是项目全局的 gradle 构建脚本，通常这个文件中的内容是不需要修改的。稍后我们将会详 细分析 gradle 构建脚本中的具体内容。\ngradle.properties这个文件是全局的 gradle 配置文件，在这里配置的属性将会影响到项目中所有的 gradle 编译 脚本。\ngradlew 和 gradlew.bat   这两个文件是用来在命令行界面中执行 gradle 命令的，其中 gradlew 是在 Linux 或 Mac 系统 中使用的，gradlew.bat 是在 Windows 系统中使用的。\nlocal.properties   这个文件用于指定本机中的 Android SDK 路径，通常内容都是自动生成的，我们并不需要修改。 除非你本机中的 Android SDK 位置发生了变化，那么就将这个文件中的路径改成新的位置即可。\nsettings.gradle   这个文件用于指定项目中所有引入的模块。通常情况下模块的引入都是自动完成的，需要我们手 动去修改这个文件的场景可能比较少。\n\n接下来看app目录下的内容：\n\nbuild主要也是包含了一些在编译时自动生成的文件。\nlibs如果你的项目中使用到了第三方 jar 包，就需要把这些 jar 包都放在 libs 目录下，放在这个目 录下的 jar 包都会被自动添加到构建路径里去。\nandroidTest   是用来编写 Android Test 测试用例的，可以对项目进行一些自动化测试。\njava   java 目录是放置我们所有 Java 代码的地方。\nres你在项目中使用到的所有图片、布局、字符 串等资源都要存放在这个目录下。当然这个目录下还有很多子目录，图片放在 drawable目录下，布 局放在 layout目录下，字符串放在 values目录下，所以你不用担心会把整个 res目录弄得乱糟糟的。\nAndroidManifest.xml这是你整个 Android 项目的配置文件，你在程序中定义的所有四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明。\ntest此处是用来编写 Unit Test 测试用例的，是对项目进行自动化测试的另一种方式。\n.gitignore这个文件用于将 app 模块内的指定的目录或文件排除在版本控制之外，作用和外层 的.gitignore 文件类似。\nbuild.gradle这是 app 模块的 gradle 构建脚本，这个文件中会指定很多项目构建相关的配置。\nproguard-rules.pro这个文件用于指定项目代码的混淆规则，当代码开发完成后打成安装包文件，如果不希望代 码被别人破解，通常会将代码进行混淆，从而让破解者难以阅读。\n\n\nAndroid系统四大组件分别是活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver） 和内容提供器（Content Provider）。\n其中活动是所有 Android 应用程序的门面，凡是在应用中你看 得到的东西，都是放在活动中的。\n而服务就比较低调了，你无法看到它，但它会一直在后台默默 地运行，即使用户退出了应用，服务仍然是可以继续运行的。\n广播接收器允许你的应用接收来自 各处的广播消息，比如电话、短信等，当然你的应用同样也可以向外发出广播消息。\n内容提供器则为应用程序之间共享数据提供了可能，比如你想要读取系统电话簿中的联系人，就需要通过内 容提供器来实现。\n\nres目录下的内容：\n\n所有以 drawable 开头的文件夹都是用来放图片的\n所有以 mipmap 开头的文件夹都是用来放应用图标的\n所有以 values 开头的文件夹都是用来放字符串、样式、颜色等配置的\nlayout 文件夹是用来放布局文件 的\n\nAndroid日志工具Log\nLog.v()。用于打印那些最为琐碎的、意义最小的日志信息。对应级别 verbose，是 Android 日志里面级别最低的一种。\nLog.d()。用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的。 对应级别 debug，比 verbose 高一级。\nLog.i()。用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分 析用户行为数据。对应级别 info，比 debug 高一级。\nLog.w()。用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修 复一下这些出现警告的地方。对应级别 warn，比 info 高一级。\nLog.e()。用于打印程序中的错误信息，比如程序进入到了 catch 语句当中。当有错误信 息打印出来的时候，一般都代表你的程序出现严重问题了，必须尽快修复。对应级别 error， 比 warn 高一级。\n\nLog.d()方法中传入了两个参数：第一个参数是 tag，一般传入当前的类名就好，主要用于 对打印信息进行过滤；第二个参数是 msg，即想要打印的具体的内容。\n","categories":["知识总结","Android"]},{"title":"先从看得到的入手.Android学习.02","url":"/2022/07/26/%E5%85%88%E4%BB%8E%E7%9C%8B%E5%BE%97%E5%88%B0%E7%9A%84%E5%85%A5%E6%89%8B-Android%E5%AD%A6%E4%B9%A0-02/","content":"活动是什么​\t活动（Activity）是最容易吸引用户的地方，它是一种可以包含用户界面的组件，主要用于 和用户进行交互。一个应用程序中可以包含零个或多个活动，但不包含任何活动的应用程序很少见。\n具体操作实例Button元素这是一个最简单的Button属性设置\n\n\nandroid：id:给与Button一个名字\nandroid:layout_width 指定了当前元素的宽 度，这里使用 match_parent 表示让当前元素和父元素一样宽。\nandroid:layout_height 指定 了当前元素的高度，这里使用 wrap_content 表示当前元素的高度只要能刚好包含里面的内容就行。\nandroid:text 指定了元素中显示的文字内容。\n\n这是一个比较复杂的Button属性设置\n\n具体参考\n\n Android基础布局之ConstraintLayout_\n\nToast元素Toast 是 Android 系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息 通知给用户，这些信息会在一段时间后自动消失，并且不会占用任何屏幕空间，我们现在就尝试 一下如何在活动中使用 Toast。\n\n@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    //使用Toast弹窗 和 退出    Button button1 =findViewById(R.id.testbutton1);    button1.setOnClickListener(new View.OnClickListener() &#123;        @Override        public void onClick(View view) &#123;            Toast.makeText(MainActivity.this, &quot;玩个屁&quot;, Toast.LENGTH_SHORT).show();        &#125;    &#125;);\n\n在活动中，可以通过 findViewById()方法获取到在布局文件中定义的元素。\n我们传入R.id.testbutton1 即在layout中定义的Button的id。\n得到按钮的实例之后，我们通过调用 setOnClickListener()方法为按钮注册一个监听器， 点击按钮时就会执行监听器中的 onClick()方法。\nToast 的用法非常简单，通过静态方法 makeText()创建出一个 Toast 对象，然后调用 show() 将 Toast 显示出来就可以了。这里需要注意的是，makeText()方法需\n要传入 3 个参数。\n第一个参 数是 Context，也就是 Toast 要求的上下文，由于活动本身就是一个 Context 对象，因此这里直 接传入MainActivity.this即可。\n第二个参数是 Toast 显示的文本内容。\n第三个参数是 Toast 显示的时长，有两个内置常量可以选择 Toast.LENGTH_SHORT 和 Toast.LENGTH_LONG。\nMenu元素首先在 res 目录下新建一个 menu 文件夹\n\n名称为menu，再右击 menu 文件夹\n\n文件名输入main。\n创建完成后再main.xml中输入如下代码\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item        android:id=&quot;@+id/add_item&quot;        android:title=&quot;Add&quot;/&gt;    &lt;!-- id:标识符  title:指定名称 --&gt;    &lt;item        android:id=&quot;@+id/remove_item&quot;        android:title=&quot;Remove&quot;/&gt;&lt;/menu&gt;\n\n​\t这里我们创建了两个菜单项，其中标签就是用来创建具体的某一个菜单项，然后通 过 android:id 给这个菜单项指定一个唯一的标识符，通过 android:title 给这个菜单项指定 一个名称。\n随后重新回到MainActivity重写onCreateOptionsMenu()方法，重写方法可以使用 Ctrl  + O 快捷键（Mac 系统是 control + O）\n\n@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123;    getMenuInflater().inflate(R.menu.main,menu);    return true;&#125;\n\n通过 getMenuInflater()方法能够得到 MenuInflater 对象，再调用它的 inflate()方法 就可以给当前活动创建菜单了。\ninflate()方法接收两个参数，第一个参数用于指定我们通过哪 一个资源文件来创建菜单，这里当然传入 R.menu.main。第二个参数用于指定我们的菜单项将添加到哪一个 Menu 对象当中，这里直接使用 onCreateOptionsMenu()方法中传入的 menu 参数。 \n然后给这个方法返回 true，表示允许创建的菜单显示出来，如果返回了 false，创建的菜单将无法显示。\n当然，仅仅让菜单显示出来是不够的，我们定义菜单不仅是为了看的，关键是要菜单真正可 用才行，因此还要再定义菜单响应事件。在 MainActivity中重写 onOptionsItemSelected()方法：\n@Overridepublic boolean onOptionsItemSelected(@NonNull MenuItem item) &#123;    switch (item.getItemId())&#123;        case R.id.add_item:            Toast.makeText(this, &quot;充值令你变强&quot;, Toast.LENGTH_SHORT).show();            break;        case R.id.remove_item:            Toast.makeText(this,&quot;删除失败&quot;,Toast.LENGTH_SHORT).show();            break;        default:            break;    &#125;    return true;&#125;\n\n这时启动程序就会有不同\n你会发现在标题栏的右侧多了一个三点的符号，这个就是菜单按钮了\n\n点击不同的菜单按钮 就会出现不同的 Toast弹窗提示\n销毁一个活动最简单的一个方法就是按一下back键就可以销毁档前的活动。\n不过如果你不想通过按 键的方式，而是希望在程序中通过代码来销毁活动，当然也可以，Activity 类提供了一个 finish() 方法，我们在活动中调用一下这个方法就可以销毁当前活动了。\n修改按钮监听器中的代码\n@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    //使用Toast弹窗 和 退出    Button button1 =findViewById(R.id.testbutton1);    button1.setOnClickListener(new View.OnClickListener() &#123;        @Override        public void onClick(View view) &#123;            Toast.makeText(MainActivity.this, &quot;玩个屁&quot;, Toast.LENGTH_SHORT).show();            finish();//关闭程序 仍然会留在后台        &#125;    &#125;);\n\n重新运行程序，这时点击一下按钮，当前的活动就被成功销毁了，效果和按下 Back 键是一 样的。\n使用Intent在活动之间穿梭​\tIntent 是 Android 程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想 要执行的动作，还可以在不同组件之间传递数据。Intent 一般可被用于启动活动、启动服务以及 发送广播等场景。\n​\tIntent 大致可以分为两种：显式 Intent 和隐式 Intent。\n​\tIntent 有多个构造函数的重载，其中一个是 Intent(Context packageContext, Class  cls)。这个构造函数接收两个参数，第一个参数 Context 要求提供一个启动活动的上下文，第 二个参数 Class 则是指定想要启动的目标活动。\n​\tActivity 类中提供了一个 startActivity()方法，这 个方法是专门用于启动活动的，它接收一个 Intent 参数，这里我们将构建好的 Intent 传入 startActivity()方法就可以启动目标活动了。\n使用显式 Intent​\t我们现在存在两个活动，现在要由主活动跳转导其他活动。\n​\t先在主活动的布局文件中创建一个Button用于进行跳转操作\n&lt;Button    android:id=&quot;@+id/testbutton3&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:orientation=&quot;vertical&quot;    android:text=&quot;快来康康&quot;    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;    app:layout_constraintEnd_toEndOf=&quot;parent&quot;    app:layout_constraintHorizontal_bias=&quot;0.949&quot;    app:layout_constraintStart_toStartOf=&quot;parent&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot;    app:layout_constraintVertical_bias=&quot;0.928&quot;    tools:ignore=&quot;MissingConstraints&quot; /&gt;\n\n​\t在主活动的Java中对Button按钮进行设置\nButton button3 =findViewById(R.id.testbutton3);button3.setOnClickListener(new View.OnClickListener() &#123;    @Override    public void onClick(View view) &#123;        Intent intent =new Intent(MainActivity.this,MainActivity2.class);        startActivity(intent);    &#125;&#125;);\n\n​\t我们首先构建出了一个 Intent，传入 MainActivity.this 作为上下文，传入 MainActivity2.class作为目标活动，这样我们的“意图”就非常明显了，即在MainActivity这个活 动的基础上打开 MainActivity2 这个活动。然后通过 startActivity()方法来执行这个 Intent。\n​\t使用这种方式来启动活动，Intent 的“意图”非常明显，因此我们称之为显式 Intent。\n使用隐式 Intent​\t相比于显式 Intent，隐式 Intent 则含蓄了许多，它并不明确指出我们想要启动哪一个活动， 而是指定了一系列更为抽象的 action 和 category 等信息，然后交由系统去分析这个 Intent， 并帮我们找出合适的活动去启动。\n通过在标签下配置的内容，可以指定当前活动能够响应的 action 和 category\n&lt;activity    android:name=&quot;.MainActivity2&quot;    android:exported=&quot;true&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;        &lt;category android:name=&quot;com.example.activitytest.MY_CATEGORY&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity\n\n在标签中我们指明了当前活动可以响应 com.example.activitytest.ACTION_  START 这个 action，而标签则包含了一些附加信息，更精确地指明了当前的活动能够响应的 Intent 中还可能带有的 category。只有和中的内容同时能够匹配 上 Intent 中指定的 action 和 category 时，这个活动才能响应该 Intent。\n//隐式intentbutton3.setOnClickListener(new View.OnClickListener() &#123;    @Override    public void onClick(View view) &#123;        Intent intent =new Intent(&quot;com.example.activitytest.ACTION_START&quot;);        intent.addCategory(&quot;com.example.activitytest.MY_CATEGORY&quot;);        startActivity(intent);    &#125;&#125;);\n\n我们使用了 Intent 的另一个构造函数，直接将 action 的字符串传了进去，表明 我们想要启动能够响应 com.example.activitytest.ACTION_START 这个 action 的活动。android.intent.category.DEFAULT 是一种默认的 category，在调 用 startActivity()方法的时候会自动将这个 category 添加到 Intent 中。\n\n每个 Intent 中只能指定一个 action，但却能指定多个 category。\n\n更多隐式 Intent 的用法使用隐式 Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使得 Android多个应用程序之间的功能共享成为了可能。\nButton button2 =findViewById(R.id.testbutton2);button2.setOnClickListener(new View.OnClickListener() &#123;    @Override    public void onClick(View view) &#123;        Intent intent = new Intent(Intent.ACTION_VIEW);        intent.setData(Uri.parse(&quot;https://m.bilibili.com/video/BV1GJ411x7h7?ts=1658824194&amp;spmid=333.938.click.openapp_popup&amp;h5_buvid=68ACC3D1-102A-14F2-15EE-8869CEC0FC1A04348infoc&amp;unique_k=&amp;bsource=&quot;));        startActivity(intent);    &#125;&#125;);\n\n上面这段代码可以调用浏览器进入指定的网站\n这里我们首先指定了 Intent 的 action 是 Intent.ACTION_VIEW，这是一个 Android 系统内 置的动作，其常量值为 android.intent.action.VIEW。然后通过 Uri.parse()方法，将一个 网址字符串解析成一个 Uri 对象，再调用 Intent 的 setData()方法将这个 Uri 对象传递进去。\n\n与此对应，我们还可以在标签中再配置一个标签，用于更精确地 指定当前活动能够响应什么类型的数据。标签中主要可以配置以下内容。\n\nandroid:scheme。用于指定数据的协议部分，如上例中的 http 部分。\nandroid:host。用于指定数据的主机名部分，例如 www.baidu.com 。\nandroid:port。用于指定数据的端口部分，一般紧随在主机名之后。\nandroid:path。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。\nandroid:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。\n\n只有标签中指定的内容和 Intent 中携带的 Data 完全一致时，当前活动才能够响应该 Intent。\n这里我们自己建立一个活动，让它也可以响应打开网页的Intent\n在 AndroidManifest.xml 中修改此活动的注册信息\n&lt;activity    android:name=&quot;.MainActivity3&quot;    android:exported=&quot;true&quot;&gt;    &lt;intent-filter tools:ignore=&quot;AppLinkUrlError&quot;&gt;        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;        &lt;!-- 响应一个打开网页的intent --&gt;        &lt;data android:scheme=&quot;https&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;\n\n重新运行程序 此时点击上个活动的链接就会多出一个选项，说明我们成功了\n\n此时如果你选择chrome打开，就可以正常打开。\n但如果你选择我们的写的活动，就会进入我们写的活动。\n除了 http 协议外，我们还可以指定很多其他协议，比如 geo 表示显示地理位置、tel 表示拨打 电话。\nButton button4 =findViewById(R.id.testbutton4);button4.setOnClickListener(new View.OnClickListener() &#123;    @Override    public void onClick(View view) &#123;        Intent intent =new Intent(Intent.ACTION_VIEW);        intent.setData(Uri.parse(&quot;tel:110&quot;));        startActivity(intent);    &#125;&#125;);\n\n这一段代码就可以让我们调用系统拨号界面，并自动填写电话号码。\n\n向下一个活动传递数据在启动活动时传递数据的思路很简单，Intent 中提供了一系列 putExtra()方法的重载，可 以把我们想要传递的数据暂存在 Intent 中，启动了另一个活动后，只需要把这些数据再从 Intent 中取出就可以了。\nButton button3 =findViewById(R.id.testbutton3);button3.setOnClickListener(new View.OnClickListener() &#123;    @Override    public void onClick(View view) &#123;        String data = &quot;can can need&quot;;        Intent intent =new Intent(MainActivity.this,MainActivity2.class);        intent.putExtra(&quot;extra_data&quot;,data);//向下传递数据data        startActivity(intent);    &#125;&#125;);\n\n这里我们还是使用显式 Intent 的方式来启动 MainActivity，并通过 putExtra()方法传递了 一个字符串。注意这里 putExtra()方法接收两个参数，第一个参数是键，用于后面从 Intent 中 取值，第二个参数才是真正要传递的数据。\n接下来我们在MainActivity2中将传递的数据取出，并打印出来\n@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main2);    Intent intent =getIntent();    String data = intent.getStringExtra(&quot;extra_data&quot;);    Log.d(&quot;MainActivity_2&quot;,data);&#125;\n\n首先可以通过 getIntent()方法获取到用于启动 SecondActivity 的 Intent，然后调用 getStringExtra()方法，传入相应的键值，就可以得到传递的数据了。这里由于我们传递的是 字符串，所以使用 getStringExtra()方法来获取传递的数据。如果传递的是整型数据，则使 用 getIntExtra()方法；如果传递的是布尔型数据，则使用 getBooleanExtra()方法，以此 类推。\n活动的生命周期返回栈Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集 合，这个栈也被称作返回栈（Back Stack）。栈是一种后进先出的数据结构，在默认情况下，每当 我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。而每当我们按下 Back 键 或调用 finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会 重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。\n活动状态每个活动在其生命周期中最多可能会有 4 种状态。\n\n运行状态当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。\n暂停状态当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。\n停止状态当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为 这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于 停止状态的活动有可能会被系统回收。\n销毁状态当一个活动从返回栈中移除后就变成了销毁状态。\n\n活动的生存期Activity 类中定义了 7 个回调方法，覆盖了活动生命周期的每一个环节，下面就来一一介绍这7个方法。\n\nonCreate()。它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如 说加载布局、绑定事件等。\nonStart()。这个方法在活动由不可见变为可见的时候调用。\nonResume()。这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于 返回栈的栈顶，并且处于运行状态。\nonPause()。这个方法在系统准备去启动或者恢复另一个活动的时候调用。\nonStop()。这个方法在活动完全不可见的时候调用。它和 onPause()方法的主要区别在 于，如果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop()方法并不会执行。\nonDestroy()。这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。\nonRestart()。这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。\n\n以上 7 个方法中除了 onRestart()方法，其他都是两两相对的，从而又可以将活动分为 3 种生存期。\n\n完整生存期。活动在 onCreate()方法和 onDestroy()方法之间所经历的，就是完整生存期。一般情况下，一个活动会在 onCreate()方法中完成各种初始化操作，而在 onDestroy()方法中完成释放内存的操作。 \n\n可见生存期。活动在 onStart()方法和 onStop()方法之间所经历的，就是可见生存期。 在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可 以通过这两个方法，合理地管理那些对用户可见的资源。比如在 onStart()方法中对资源进行加载，而在 onStop()方法中对资源进行释放，从而保证处于停止状态的活动不会占用过多内存。 \n\n前台生存期。活动在onResume()方法和 onPause()方法之间所经历的就是前台生存期。 在前台生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行交互的，我 们平时看到和接触最多的也就是这个状态下的活动。\n\n\n用图文表示\n\nonSaveInstanceState()回调方法onSaveInstanceState()回调方法可以保证在活动被回收之前一定会被调用，因此我们可以通过这个方法来解决活动被回收时临 时数据得不到保存的问题。\nonSaveInstanceState()方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方 法用于保存数据，比如可以使用 putString()方法保存字符串，使用 putInt()方法保存整型数 据，以此类推。\n每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle 中取值，第二个参数是真正要保存的内容。\n在 MainActivity 中添加如下代码就可以将临时数据进行保存：\n//暂存数据@Overrideprotected void onSaveInstanceState(@NonNull Bundle outState) &#123;    super.onSaveInstanceState(outState);    String temData = &quot;show show word&quot;;    outState.putString(&quot;data_key&quot;,temData);&#125;\n\n在onCreate方法中获得数据，并打印出来\n//获得销毁前的数据if(savedInstanceState!=null)&#123;    String temData =savedInstanceState.getString(&quot;data_key&quot;);    Log.d(&quot;TAG&quot;,temData);&#125;\n\n取出值之后再做相应的恢复操作就可以了，比如说将文本内容重新赋值到文本输入框上。\n活动的启动模式\nstandard模式\nstandard 是活动默认的启动模式，在不进行显式指定的情况下，所有活动都会自动使用这种启动模式。在 standard 模式（即默认情况）下，每当启 动一个新的活动，它就会在返回栈中入栈，并处于栈顶的位置。对于使用 standard 模式的活动， 系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。\n\n\nsingleTop 模式当活动的启动模式指定为 singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。每当想要再启动一个 FirstActivity 时都会直接使用栈顶的活动，因此 FirstActivity 也只会有一个实例，仅按一次 Back 键就可以退出程序。不过当 FirstActivity 并未处于栈顶位置时，这时再启动 FirstActivity，还是会创建新的实例的。\n\nsingleTask模式当活动的启动模式指定为 singleTask，每次启动该活动时系统首先会在返回栈中检查是否 存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。\n\nsingleInstance 模式\n\n\n   指定为singleInstance 模式的活动会启用一个新的返回栈来管理这个活动。   \n\nsingleInstancePerTask模式Android12版本新增运行模式和singleTask几乎一样，不过singleInstancePerTask不需要为启动的Activity设置一个特殊的taskAffinity才能创建一个新的Task。\n\n小技巧知晓当前是在哪一个活动新建一个BaseActivity类，让BaseActivity继承AppCompatActivity，并重写onCreate()方法。\npublic class BaseActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        Log.d(&quot;BaseActivity&quot;,getClass().getSimpleName());//打印活动名    &#125;&#125;\n\n接下来我们需要让 BaseActivity 成为 ActivityTest 项目中所有活动的父类。\n而由于 BaseActivity 又是继承自 AppCompatActivity 的，所以 项目中所有活动的现有功能并不受影响，它们仍然完全继承了 Activity 中的所有特性。\n现在每当我们进入到一个活动的界面，该活动的类名就会被打印出来，这样我们就可以时时 刻刻知晓当前界面对应的是哪一个活动了\n随时随地退出程序用一个专门的集合类对所有的活动进行管理\npublic class ActivityCollector &#123;    public static List&lt;Activity&gt; activities =new ArrayList&lt;&gt;();    public static void addActivity(Activity activity) &#123;        activities.add(activity);    &#125;    public static void removeActivity(Activity activity)&#123;        activities.remove(activity);    &#125;    public static void finishAll()&#123;        for(Activity activity : activities)&#123;            if (!activity.isFinishing())&#123;                activity.finish();            &#125;        &#125;        activities.clear();    &#125;&#125;\n\n我们通过一个 List 来暂存活动，然后提供了一个 addActivity()方法用 于向 List 中添加一个活动，提供了一个 removeActivity()方法用于从 List 中移除活动，最后提 供了一个 finishAll()方法用于将 List 中存储的活动全部销毁掉。\n还要修改BaseActivity类中的代码\npublic class BaseActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        Log.d(&quot;BaseActivity&quot;,getClass().getSimpleName());        ActivityCollector.addActivity(this);    &#125;    @Override    protected void onDestroy() &#123;        super.onDestroy();        ActivityCollector.removeActivity(this);    &#125;&#125;\n\n在 BaseActivity 的 onCreate()方法中调用了 ActivityCollector 的 addActivity()方 法，表明将当前正在创建的活动添加到活动管理器里。然后在 BaseActivity 中重写 onDestroy() 方法，并调用了 ActivityCollector 的 removeActivity()方法，表明将一个马上要销毁的活 动从活动管理器里移除。\n从此以后，不管你想在什么地方退出程序，只需要调用 ActivityCollector.finishAll() 方法就可以了。\n\n前提是：所有类都继承了BaseActivity。\n\n","categories":["知识总结","Android"]},{"title":"crackme2","url":"/2022/07/28/crackme2/","content":"观察题目是apk文件用jadx反编译\n在com包下的example.CrackMe2目录下的MainActivity中 \n\n看到解题的关键\n很简单是一个魔改的RC4加密 RC4加密解密用一套算法\n脚本只要将我们得到的密文当成原文输入即可的到真正的原文即flag\npublic  class wp&#123;      /**     * @param encrypt     * @param keys     * @return     */    public static  String encode(char[] encrypt, String keys) &#123;        char[] keyBytes = new char[256];        char[] cypherBytes = new char[256];        for (int i = 0; i &lt; 256; i++)         &#123;            keyBytes[i] = keys.charAt(i % keys.length());            cypherBytes[i] = (char) i;        &#125;        int jump = 0;        for (int i2 = 0; i2 &lt; 256; i2++) &#123;            jump = (cypherBytes[i2] + jump + keyBytes[i2]) &amp; 255;            char tmp = cypherBytes[i2];            cypherBytes[i2] = cypherBytes[jump];            cypherBytes[jump] = tmp;        &#125;        int i3 = 0;        int jump2 = 0;        StringBuilder Result = new StringBuilder();        for (int x = 0; x &lt; encrypt.length; x++) &#123;            i3 = (i3 + 1) &amp; 255;            char tmp2 = cypherBytes[i3];            jump2 = (jump2 + tmp2 + 136) &amp; 255;            char t = (char) ((cypherBytes[jump2] + tmp2) &amp; 255);            cypherBytes[i3] = cypherBytes[jump2];            cypherBytes[jump2] = tmp2;            try &#123;                Result.append(new String(new char[]&#123;(char) (encrypt[x] ^ cypherBytes[t])&#125;));            &#125; catch (Exception e) &#123;                e.printStackTrace();                return &quot;&quot;;            &#125;        &#125;        return Result.toString();    &#125;    public static void main(String[]args)&#123;            char[] target = &#123;205, &#x27;R&#x27;, &#x27;t&#x27;, &#x27;z&#x27;, 30, &#x27;\\b&#x27;, &#x27;\\b&#x27;, 224, &#x27;W&#x27;, &#x27;;&#x27;, 24, 153, 175, &#x27;=&#x27;, 29, 148, 21, &#x27;%&#x27;, &#x27;g&#x27;, &#x27;[&#x27;, &#x27;d&#x27;, &#x27;S&#x27;, 31, &#x27;;&#x27;, 220, 162, &#x27;F&#x27;, &#x27;6&#x27;, 211, 253, 190, &#x27;3&#x27;&#125;;            String result =encode(target,&quot;happygame&quot;);            System.out.println(&quot;flag&#123;&quot;+result+&quot;&#125;&quot;);            &#125;  &#125;    \n\n","categories":["比赛WP","2022CISCN华中分区赛","re"]}]